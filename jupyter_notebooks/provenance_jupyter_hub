import json
%pip install -q rspace-client==2.6.1
%pip install -q pickleshare
try:
    from notebook import app
except:
    %conda install -q notebook
%pip install -q keyring
from rspace_client.eln import eln
import os
import hashlib
import json
%pip install -q dill
import dill
%pip install -q ipynbname
import ipynbname
%pip install -q ipylab
from ipylab import JupyterFrontEnd
import traceback
%pip install -q lxml
from bs4 import BeautifulSoup
import nbformat
import asyncio

RSPACE_DOC_FOR_NOTEBOOK = 'rspace_doc_for_notebook'
ATTACHMENTS_FOR_NOTEBOOK = 'data_attached_to_notebook'
GALLERY_FILE_FOR_NOTEBOOK = 'file_for_notebook'

# Your RSpace instance goes here
RSPACE_URL="https://researchspace2.eu.ngrok.io/"

"""
    All data that will be saved to RSpace along with this notebook: select the data in the file browser and choose 'copy path'
    then paste here using a ',' comma to separate files if there is more than one.

    Example:
            attached_data_files = "spectroscopy_data.csv, data/spectroscopy_data2.csv, data/spectroscopy_data3.csv"

    If you wish to have no attached data, set this value to be "" (a pair of double quotes)

    Example:
            attached_data_files = ""
"""
attached_data_files = "spectroscopy_data.csv,data/spectroscopy_data2.csv,data/spectroscopy_data3.csv"

rspace_client = None
app = JupyterFrontEnd()


def get_notebook_name():
    nb_fname = ipynbname.name()
    nb_path = str(ipynbname.path())
    ext_pos=(''+nb_path).rfind('.')
    ext=nb_path[ext_pos:]
    # print(f"{ext=}")
    # print(f"{nb_fname=}")
    # print(f"{nb_path=}")
    return {'name':nb_fname+ext, 'part_name':nb_fname,'path':nb_path}

def get_password():
    """
    Retrieves password from (or saves a new password to) keyring
    """
    try:
        import getpass
        import keyring

        # TODO - Define the service name (e.g., the notebook name the secret is for)
        service_id = "RSpaceJupyterDemoApp"
        # TODO - Define the username associated with the secret
        username = "myuser"  # use your own username

        retrieved_password = keyring.get_password(service_id, username)
        if retrieved_password is None:
            retrieved_password = getpass.getpass("Please enter your RSpace Api key: ")
            keyring.set_password(service_id, username, retrieved_password)
        return retrieved_password
    except Exception as e:
        print(f"Error getting password: {e}")
        return None

def get_rspace_client():
    """
    Returns rspace ELN API client
    """
    try:
        global rspace_client
        if rspace_client is None:
            retrieved_password = get_password()
            rspace_client = eln.ELNClient(RSPACE_URL, retrieved_password)
            print(rspace_client.get_status())
        return rspace_client
    except Exception as e:
        print(traceback.format_exc())
        print(f"Error connecting to RSpace: {e}")
        return None

def save_rspace_data(rspace_doc, attachments, gallery_file):
    # Define the filename to save the state
    state_filename = get_notebook_name()['part_name']+"_state.pkl"

    with open(state_filename, 'wb') as f:
        dill.dump({RSPACE_DOC_FOR_NOTEBOOK: rspace_doc, ATTACHMENTS_FOR_NOTEBOOK: attachments, GALLERY_FILE_FOR_NOTEBOOK: gallery_file}, f)

def load_data():
    state_filename = get_notebook_name()['part_name']+"_state.pkl"

    if os.path.exists(state_filename):
        # Load the variables from the file using dill
        with open(state_filename, 'rb') as f:
            try:
                loaded_state = dill.load(f)
            except Exception as e:
                loaded_state = {}
    else:
        print(f"State file '{state_filename}' not found. No variables loaded.")
    return loaded_state

async def save_notebook():
    app.commands.execute('docmanager:save')
    # 'docmanager:save' does not appear to hook into any callback invoked when the document is actually saved
    await asyncio.sleep(1)

async def reload_notebook():
    app.commands.execute('docmanager:reload')
    # 'docmanager:reload' does not appear to hook into any callback invoked when the document is actually reloaded
    await asyncio.sleep(1)

def make_metadata_cell(text):
    loaded_state = load_data()
    rspace_document_file_id = loaded_state.get(RSPACE_DOC_FOR_NOTEBOOK)
    attachment_files = loaded_state.get(ATTACHMENTS_FOR_NOTEBOOK, {})
    nb_gallery_file = loaded_state.get(GALLERY_FILE_FOR_NOTEBOOK, {})
    nb_gallery_file_id = nb_gallery_file['id']
    nb_gallery_file_version = nb_gallery_file['version']
    nb_gallery_file_name = nb_gallery_file['name']
    meta_data_cell = nbformat.v4.new_markdown_cell()
    galery_doc_link = f'"<a href="{RSPACE_URL}gallery/item/{nb_gallery_file_id}" target="_blank">This Notebook in RSpace</a>'
    rspace_doc_for_markdown = f'[The RSpace Document describing this notebook]({RSPACE_URL}workspace/editor/structuredDocument/{rspace_document_file_id})'
    gallery_doc_markdown = f'[This Notebook in RSpace Gallery: {nb_gallery_file_name} version: {nb_gallery_file_version}]({RSPACE_URL}gallery/item/{nb_gallery_file_id})'
    meta_data_cell['source'] = rspace_doc_for_markdown + "<br>" + gallery_doc_markdown
    attached_data_files_list = attached_data_files.split(",")
    for attached_data in attached_data_files_list:
        attachment_file_id = attachment_files.get(attached_data, {}).get('id')
        attachment_version = attachment_files.get(attached_data, {}).get('version')
        meta_data_cell['source'] +=f'<br>[Attached Data {attached_data} version: {attachment_version} ]({RSPACE_URL}gallery/item/{attachment_file_id})'
    meta_data_cell['metadata'] = {"rspace_metadata": {"documentFor": "docid","notebook_file":"docid", "attachments": ["attch1","attach2"]} }
    return meta_data_cell

async def add_rspace_details_to_notebook_metadata(fname, text):
    await save_notebook()
    with open(fname, 'r') as original:
        nb = nbformat.read(original, nbformat.NO_CONVERT)
        meta_data_cell = make_metadata_cell(text)
        replaced = False
        for i, cell in enumerate(nb['cells']):
            if 'rspace_metadata' in cell['metadata']:
                nb["cells"][i] = meta_data_cell
                replaced = True
        if replaced is False:
            nb["cells"].extend([meta_data_cell])
    with open(fname, 'w', encoding='utf-8') as modified:
        nbformat.write(nb, modified)
    await reload_notebook()

def make_content(nb_gallery_file_id,attachment_files):
    content = f"""
                <fileId={nb_gallery_file_id}>
                """
    for  attachment_file in attached_data_files.split(","):
        content += f"""
        <fileId={attachment_files.get(attachment_file)['id']}>
        """
    print(f"content is {content}")
    return content

def remove_jupyter_attachment_divs(content, nb_gallery_file_id, attachment_files):
    soup = BeautifulSoup(content, 'html.parser')
    attachment_divs = soup.find_all("div", {"class": "attachmentDiv"})
    for attachment_div in attachment_divs:
        href_tag = attachment_div.find('a')
        print(f"href_tag{href_tag}")
        gallery_link = '/Streamfile/' + str(nb_gallery_file_id)
        for  attachment_file in attached_data_files.split(","):
            attachment_file_id = attachment_files.get(attachment_file, {}).get('id')
            attachment_link = '/Streamfile/' + str(attachment_file_id)
            if attachment_link == href_tag['href'] or gallery_link == href_tag['href']:
                attachment_div.decompose()
                break
    return soup.prettify()

def upload_file_to_gallery(rspaceid, file, client):
    if rspaceid is None:
        print('start upload file')
        uploaded = client.upload_file(file)
        rspace_id = uploaded['id']
        rspace_version = uploaded['version']
    else:
        print('start update file')
        updated = client.update_file(file,rspaceid)
        rspace_id = updated['id']
        rspace_version = updated['version']
    print(f"RSpace ID is: {rspace_id} and version is {rspace_version} for file {file}")
    rspace_file_data = {"id": rspace_id, "version": rspace_version}
    return rspace_file_data

def upload_attached_data(attachment_files):
    client = get_rspace_client()
    attached_data_files_list = attached_data_files.split(",")
    for attached_data in attached_data_files_list:
        if attached_data:
            with open(attached_data, 'r', encoding='utf-8') as attch:
                attachment_file_id = attachment_files.get(attached_data,{}).get('id')
                attachment_file_data = upload_file_to_gallery(attachment_file_id, attch, client)
                attachment_files[attached_data] = attachment_file_data
    print(f"attached files: {attachment_files}")

async def sync_notebook():
    """
    Saves notebook using ipylab and then writes notebook to Rspace document as
    an attachment
    """
    rspace_document_file_id = None
    attachment_filess = None
    gallery_file = None
    await save_notebook()
    try:
        loaded_state = load_data()
        rspace_document_file_id = loaded_state.get(RSPACE_DOC_FOR_NOTEBOOK)
        attachment_files = loaded_state.get(ATTACHMENTS_FOR_NOTEBOOK, {})
        nb_gallery_file = loaded_state.get(GALLERY_FILE_FOR_NOTEBOOK, {})
        nb_gallery_file_id = nb_gallery_file.get('id')
        current_notebook = get_notebook_name()['name']
        location = os.getcwd()
        attachments = None
        if rspace_document_file_id is not None:
            print(f"An RSpace document with this notebook as an attachment saved previously with RSpaceID {rspace_document_file_id}" )
        else:
            print("No RSpace document with this notebook as an attachment saved previously in RSpace")
        if nb_gallery_file_id is not None:
            print(f"This notebook saved previously to Gallery with RSpaceID {nb_gallery_file_id}" )
        else:
            print("Notebook not previously saved to RSpace Gallery")
        upload_attached_data(attachment_files)
        with open(current_notebook, 'r', encoding='utf-8') as f:
            client = get_rspace_client()

            if nb_gallery_file_id is None:
                print('start upload notebook to gallery')
                nb_gallery_file = client.upload_file(f)
                nb_gallery_file_id = nb_gallery_file['id']
                print(f"Notebook Gallery file is: {nb_gallery_file}")
                print('done upload notebook to gallery')
            else:
                print('start update notebook in gallery')
                nb_gallery_file = client.update_file(f, nb_gallery_file_id)
                print('end update to gallery')
                print(f"Notebook Gallery file ID is: {gallery_file}")

            if rspace_document_file_id is None:
                new_doc = client.create_document(name="DocumentFor_"+current_notebook,tags = ["Python", "API", "Jupyter"] )
                rspace_document_file_id = new_doc['id']
                content = make_content(nb_gallery_file_id,attachment_files)
                client.append_content(new_doc['id'], content)
                print(f"New document with this notebook as attachement has ID: {new_doc['id']}")
            else:
                previous_content = client.get_document(rspace_document_file_id)['fields'][0]['content']
                previous_content = remove_jupyter_attachment_divs(previous_content, nb_gallery_file_id, attachment_files)
                new_content = previous_content + make_content(nb_gallery_file_id,attachment_files)
                updated_doc = client.update_document(rspace_document_file_id,tags = ['Python', 'API', 'Jupyter'], fields = [{"content": new_content}])
            save_rspace_data(rspace_document_file_id, attachment_files, nb_gallery_file)
            await add_rspace_details_to_notebook_metadata(current_notebook, location)

    except Exception as e:
        print(traceback.format_exc())
        print(f"Error reading notebook file: {e}")
        return None

await sync_notebook()

