import json
%pip install -q rspace-client==2.6.1
%pip install -q pickleshare
try:
    from notebook import app
except:
    %conda install -q notebook
%pip install -q keyring
from rspace_client.eln import eln
import os
import hashlib
import json
%pip install -q dill
import dill
%pip install -q ipynbname
import ipynbname
%pip install -q ipylab
from ipylab import JupyterFrontEnd
import traceback
%pip install -q lxml
from bs4 import BeautifulSoup
import nbformat
import asyncio
import getpass
import keyring

RSPACE_DOC_FOR_NOTEBOOK = 'rspace_doc_for_notebook'
ATTACHMENTS_FOR_NOTEBOOK = 'data_attached_to_notebook'
GALLERY_FILE_FOR_NOTEBOOK = 'file_for_notebook'

# Your RSpace instance goes here
RSPACE_URL="https://researchspace2.eu.ngrok.io/"

"""
    All data that will be saved to RSpace along with this notebook: select the data in the file browser and choose 'copy path'
    then paste here using a ',' comma to separate files if there is more than one.

    Example:
            attached_data_files = "spectroscopy_data.csv, data/spectroscopy_data2.csv, data/spectroscopy_data3.csv"

    If you wish to have no attached data, set this value to be "" (a pair of double quotes)

    Example:
            attached_data_files = ""
"""
attached_data_files = "spectroscopy_data.csv,data/spectroscopy_data2.csv,data/spectroscopy_data3.csv"
get_new_password = False

rspace_client = None
app = JupyterFrontEnd()


def get_notebook_name():
    nb_fname = ipynbname.name()
    nb_path = str(ipynbname.path())
    ext_pos=(''+nb_path).rfind('.')
    ext=nb_path[ext_pos:]
    return {'name':nb_fname+ext, 'part_name':nb_fname,'path':nb_path}

def get_password():
    """
    Retrieves password from (or saves a new password to) keyring
    """
    try:

        # TODO - Define the service name (e.g., the notebook name the secret is for)
        service_id = "RSpaceJupyterDemoApp"
        # TODO - Define the username associated with the secret
        username = "myuser"  # use your own username

        retrieved_password = keyring.get_password(service_id, username)
        if retrieved_password is None or get_new_password:
            retrieved_password = getpass.getpass("Please enter your RSpace Api key: ")
            keyring.set_password(service_id, username, retrieved_password)
        return retrieved_password
    except Exception as e:
        print(f"Error getting password: {e}")
        return None

def get_rspace_client():
    """
    Returns rspace ELN API client
    """
    try:
        global rspace_client
        if rspace_client is None:
            retrieved_password = get_password()
            rspace_client = eln.ELNClient(RSPACE_URL, retrieved_password)
            print(rspace_client.get_status())
        return rspace_client
    except Exception as e:
        print(traceback.format_exc())
        print(f"Error connecting to RSpace: {e}")
        return None

def save_rspace_data(rspace_doc, attachments, gallery_file):
    # Define the filename to save the state
    state_filename = get_notebook_name()['part_name']+"_state.pkl"
    print(f"writing to file: {state_filename}")
    with open(state_filename, 'wb') as f:
        dill.dump({RSPACE_DOC_FOR_NOTEBOOK: rspace_doc, ATTACHMENTS_FOR_NOTEBOOK: attachments, GALLERY_FILE_FOR_NOTEBOOK: gallery_file}, f)

def load_data():
    state_filename = get_notebook_name()['part_name']+"_state.pkl"

    if os.path.exists(state_filename):
        # Load the variables from the file using dill
        with open(state_filename, 'rb') as f:
            try:
                loaded_state = dill.load(f)
            except Exception as e:
                loaded_state = {}
    else:
        loaded_state = {}
        print(f"State file '{state_filename}' not found. No variables loaded.")
    return loaded_state

async def save_notebook():
    app.commands.execute('docmanager:save')
    # 'docmanager:save' does not appear to hook into any callback invoked when the document is actually saved
    await asyncio.sleep(1)

async def reload_notebook():
    app.commands.execute('docmanager:reload')
    # 'docmanager:reload' does not appear to hook into any callback invoked when the document is actually reloaded
    await asyncio.sleep(1)

def make_metadata_cell(nb_gallery_file, attachment_files,rspace_document_file_id ):
    nb_gallery_file_id = nb_gallery_file['id']
    nb_gallery_file_version = int(nb_gallery_file['version']) +1
    nb_gallery_file_name = nb_gallery_file['name']
    meta_data_cell = nbformat.v4.new_markdown_cell()
    galery_doc_link = f'"<a href="{RSPACE_URL}gallery/item/{nb_gallery_file_id}" target="_blank">This Notebook in RSpace</a>'
    rspace_doc_for_markdown = f'[The RSpace Document describing this notebook]({RSPACE_URL}workspace/editor/structuredDocument/{rspace_document_file_id})'
    gallery_doc_markdown = f'[This Notebook in RSpace Gallery: {nb_gallery_file_name} version: {nb_gallery_file_version}]({RSPACE_URL}gallery/item/{nb_gallery_file_id})'
    meta_data_cell['source'] = rspace_doc_for_markdown + "<br>" + gallery_doc_markdown
    attached_data_files_list = attached_data_files.split(",")
    for attached_data in attached_data_files_list:
        attachment_file_id = attachment_files.get(attached_data, {}).get('id')
        attachment_version = attachment_files.get(attached_data, {}).get('version')
        meta_data_cell['source'] +=f'<br>[Attached Data {attached_data} version: {attachment_version} ]({RSPACE_URL}gallery/item/{attachment_file_id})'
    meta_data_cell['metadata'] = {"rspace_metadata": {"documentFor": "docid","notebook_file":"docid", "attachments": [""]} }
    return meta_data_cell

async def add_rspace_details_to_notebook_metadata(fname, nb_gallery_file, attachment_files,rspace_document_file_id ):
    """
    We have to save meta data about a notebook before its been uploaded to the gallery.
    Therefore increment version by 1 when writing the metadata. If nb_gallery_file[id] is None
    its the initial upload to the Gallery and so do not write any meta data
    """
    if nb_gallery_file.get('id') is None:
        return
    await save_notebook()
    with open(fname, 'r') as original:
        nb = nbformat.read(original, nbformat.NO_CONVERT)
        meta_data_cell = make_metadata_cell(nb_gallery_file, attachment_files, rspace_document_file_id)
        replaced = False
        for i, cell in enumerate(nb['cells']):
            if 'rspace_metadata' in cell['metadata']:
                nb["cells"][i] = meta_data_cell
                replaced = True
        if replaced is False:
            nb["cells"].extend([meta_data_cell])
    with open(fname, 'w', encoding='utf-8') as modified:
        nbformat.write(nb, modified)

def make_content(nb_gallery_file_id,attachment_files):
    content = f"""
                <fileId={nb_gallery_file_id}>
                """
    for  attachment_file in attached_data_files.split(","):
        content += f"""
        <fileId={attachment_files.get(attachment_file)['id']}>
        """
    print(f"content is {content}")
    return content

def remove_jupyter_attachment_divs(content, nb_gallery_file_id, attachment_files):
    soup = BeautifulSoup(content, 'html.parser')
    attachment_divs = soup.find_all("div", {"class": "attachmentDiv"})
    for attachment_div in attachment_divs:
        href_tag = attachment_div.find('a')
        print(f"href_tag{href_tag}")
        gallery_link = '/Streamfile/' + str(nb_gallery_file_id)
        for  attachment_file in attached_data_files.split(","):
            attachment_file_id = attachment_files.get(attachment_file, {}).get('id')
            attachment_link = '/Streamfile/' + str(attachment_file_id)
            if attachment_link == href_tag['href'] or gallery_link == href_tag['href']:
                attachment_div.decompose()
                break
    return soup.prettify()

def upload_file_to_gallery(rspaceid, file, client):
    if rspaceid is None:
        print(f'start upload file {file} using {client}')
        data = client.upload_file(file)
    else:
        print('start update file')
        data = client.update_file(file,rspaceid)
    return data

def calc_hash(filename):
    sha256_hash = hashlib.sha256()
    with open(filename,"rb") as f:
        # Read and update hash string value in blocks of 4K
        for byte_block in iter(lambda: f.read(4096),b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def upload_attached_data(attachment_files):
    client = get_rspace_client()
    attached_data_files_list = attached_data_files.split(",")
    for attached_data in attached_data_files_list:
        if attached_data:
            with open(attached_data, 'r', encoding='utf-8') as attch:
                attachment_file_id = attachment_files.get(attached_data,{}).get('id')
                attachment_file_hash = attachment_files.get(attached_data,{}).get('hash')
                calc_latest_hash = calc_hash(attached_data)
                if calc_latest_hash != attachment_file_hash:
                    attachment_file_data = upload_file_to_gallery(attachment_file_id, attch, client)
                    attachment_file_data['hash'] = calc_latest_hash
                    attachment_files[attached_data] = attachment_file_data
                else:
                    print(f"File {attached_data} not changed so no update")
    print(f"attached files: {attachment_files}")

async def upload_notebook_to_gallery(current_notebook, nb_gallery_file, attachment_files, rspace_document_file_id):
    """
    Metadata about the notebook is written to the notebook before it us uploaded to the Gallery (and the version incremented predictively by one).
    If the notebook has never been uploaded to the Gallery we have no stored rspace-id to write to the meta data and so we do not write any meta data.
    We do the initial upload (which creates a Gallery file with version = '1'.  Then we write meta data (incrementing the version to '2' and upload the notebook
    a second time.
    """
    await add_rspace_details_to_notebook_metadata(current_notebook, nb_gallery_file, attachment_files, rspace_document_file_id)
    with open(current_notebook, 'r', encoding='utf-8') as nb_file:
        client = get_rspace_client()
        nb_gallery_file = upload_file_to_gallery(nb_gallery_file.get('id'), nb_file, client)
        print(f"gallery file for nb: {nb_gallery_file}")
        if nb_gallery_file.get('version') == 1:
            await add_rspace_details_to_notebook_metadata(current_notebook, nb_gallery_file, attachment_files, rspace_document_file_id)
            nb_gallery_file = upload_file_to_gallery(nb_gallery_file.get('id'), nb_file, client)
            print(f"nb_gallery_file was uploaded a second time and was : {nb_gallery_file}")
    await reload_notebook()
    return nb_gallery_file

async def sync_notebook():
    """
    Saves notebook using ipylab and then writes notebook to Rspace document as
    an attachment
    """
    rspace_document_file_id = None
    attachment_filess = None
    gallery_file = None
    await save_notebook()
    try:
        loaded_state = load_data()
        client = get_rspace_client()
        rspace_document_file_id = loaded_state.get(RSPACE_DOC_FOR_NOTEBOOK)
        attachment_files = loaded_state.get(ATTACHMENTS_FOR_NOTEBOOK, {})
        nb_gallery_file = loaded_state.get(GALLERY_FILE_FOR_NOTEBOOK, {})
        nb_gallery_file_id = nb_gallery_file.get('id')
        current_notebook = get_notebook_name()['name']
        attachments = None
        if rspace_document_file_id is not None:
            print(f"An RSpace document with this notebook as an attachment saved previously with RSpaceID {rspace_document_file_id}" )
        else:
            print("No RSpace document with this notebook as an attachment saved previously in RSpace")
        upload_attached_data(attachment_files)
        if nb_gallery_file_id is not None:
            print(f"This notebook saved previously to Gallery with RSpaceID {nb_gallery_file_id}" )
        else:
            print("Notebook not previously saved to RSpace Gallery")
        if rspace_document_file_id is None:
            new_doc = client.create_document(name="DocumentFor_"+current_notebook,tags = ["Python", "API", "Jupyter"] )
            rspace_document_file_id = new_doc['id']
        nb_gallery_file = await upload_notebook_to_gallery(current_notebook, nb_gallery_file,attachment_files, rspace_document_file_id)
        print(f"nb_gallery_file was finally: {nb_gallery_file}")
        nb_gallery_file_id = nb_gallery_file.get('id')

        previous_content = client.get_document(rspace_document_file_id)['fields'][0]['content']
        previous_content = remove_jupyter_attachment_divs(previous_content, nb_gallery_file_id, attachment_files)
        new_content = previous_content + make_content(nb_gallery_file_id,attachment_files)
        updated_doc = client.update_document(rspace_document_file_id,tags = ['Python', 'API', 'Jupyter'], fields = [{"content": new_content}])
        save_rspace_data(rspace_document_file_id, attachment_files, nb_gallery_file)

    except Exception as e:
        print(traceback.format_exc())
        print(f"Error reading notebook file: {e}")
        return None

await sync_notebook()
